## 本章简介
&emsp;&emsp;本章作为选学章节，主要讲解两种常见的排序算法：冒泡排序、插入排序。

&emsp;&emsp;从实际编程的角度看，很少需要自己编写算法实现排序，Java的一些工具类中提供了一些静态方法可以实现排序的功能。但作为程序员，还是需要对一些简单的排序算法有一定了解，至少企业面试的时候经常会被要求写出指定的排序算法。

 

## 10.1  排序算法

 

&emsp;&emsp;所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减地排列起来的操作。排序的算法有很多，各种算法对空间的要求及时间效率也各有差别。其中插入排序和冒泡排序又被称作简单排序，它们对空间的要求不高，但时间效率不稳定。而其他一些排序相对于简单排序来说对空间的要求稍高一点，但时间效率却能稳定在很高的水平。关于空间要求和时间效率的问题，有兴趣的可以找其他参考资料研究一下。

### 10.1.1  冒泡排序  

&emsp;&emsp;冒泡排序就是依次比较相邻的两个数，将小数放在前面，大数放在后面。

&emsp;&emsp;第一轮：首先比较第1个和第2个数，将小数放前，大数放后；然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后；至此第一轮结束，将最大的数放到了最后。

&emsp;&emsp;第二轮：仍从第一对数开始比较，将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的数），第二轮结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。

&emsp;&emsp;按此规律操作，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，类似于小的气泡往上升，所以称作冒泡排序。

&emsp;&emsp;通过上面的分析可以看出，假设需要排序的序列的个数是n，则需要经过n-1轮，最终完成排序。在第一轮中，比较的次数是n-1次，之后每轮减少1次。

&emsp;&emsp;用Java语言实现冒泡排序，可以用双重for循环实现，其核心代码如下。


```
static void bubbleSort(int[] a) {                                  //引用传递

    int temp;

    //数组的长度可以通过“数组名.length”获得

    for (int i = 0; i < a.length-1; i++) {                   //需要比较n-1轮

        for (int j = 0; j < a.length-i-1 ; j++) {      //根据a.length-i-1，每轮需要比较的次数逐轮减少1次

            if (a[j] > a[j+1]) {                           //相邻数进行比较，符合条件进行替换

                temp = a[j];

                a[j] = a[j+1];

                a[j+1] = temp;

            }

        }

    }

}
```
### 10.1.2  插入排序  

&emsp;&emsp;插入排序包括直接插入排序、二分插入排序、链表插入排序和希尔排序。接下来介绍最简单的直接插入排序。

&emsp;&emsp;直接插入排序存在两个表，一个是有序表，另一个是无序表。每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。

&emsp;&emsp;第一轮：比较无序表中前两个数，然后按顺序插入到有序表中，剩下的数仍在无序表中。

&emsp;&emsp;第二轮：把无序表中剩下的第一个数与有序表的两个数进行比较，然后把这个数插入到合适位置。

&emsp;&emsp;按此规律操作，直至无序表中的数全部插入到有序表，完成排序。

&emsp;&emsp;用Java语言实现直接插入排序的核心代码如下。


```
static void insertSort(int[] a) {                          //引用传递

    for(int i = 1;i < a.length; i++){

        int j = -1;

        while(j <= i && a[i] > a[++j]){     //找到a[i]应该摆放的位置

            if(j < i){

                //将j之后的数据移动一位，然后把a[i]移动到j处

                int temp = a[i];

                for(int k = i-1;k >= j;k--){

                a[k+1] = a[k];

            }

            a[j] = temp;

        }

    }

}
```


&emsp;&emsp;直接插入排序没有充分地利用“已插入的数据已经排序”这个事实，因此有很多针对直接插入排序改进的算法，例如二分插入排序等，这里不再赘述。




## 10.2  上机任务



#### 目标：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13，求出这个数列的前20项之和。

 


时间：15分钟。

形式：每个学员独立完成，小组组长检查。

工具：EditPlus。

实现思路：

 

&emsp;&emsp;（1）从序列中可以看出规律，后一个分数的分子是前一个分数分子与分母之和，后一个分数的分母是前一个分数的分子。

&emsp;&emsp;（2）声明一个长度为21的整型数组a，前20个整数用于存放这个序列前20项的分母，第21个整数用于存放这个序列第20项的分子，a[0] = 1; a[1] = 2; a[2] = a[0] + a[1]。

&emsp;&emsp;（3）第i项的分数为a[i]/a[i-1]（需要强制转换成double类型）。

##  10.3  本章练习

1  如何通过冒泡排序、插入排序实现从大到小的排序？ 

 


2  简述冒泡排序、插入排序的实现原理。

 


3  有5名学生，每个学生都有姓名和年龄属性。请分别使用冒泡排序和插入排序，按照年龄从小到大，依次输出这5名学生的姓名。

 